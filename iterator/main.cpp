/*****************************************************************
*  			STL中的基本的概念			
	容器：可容纳各种数据类型的通用数据结构，是类模板
　　迭代器：可用于依次存取容器中的元素，类似于指针
　　算法：用来操作容器中的元素的函数模板


			容器概述
可以用于存放各种类型的数据（基本类型的变量，对象等）的数据结构，都是类模板，分为三种：
1）顺序容器
　　vector（动态数组，一维数组），deque（双向队列），list（双向链表）
2）关联容器
　　set，multiset，map，multimap（本质上来说都是平衡二叉树，查找效率高，自带排序）
3）容器适配器
　　stack（栈），queue（队列），priority_queue（优先级队列）
对象被插入容器中时，被插入的是对象的一个复制品。许多算法，比如排序，查找，要求对容器中的元素进行比较，
有的容器本身就是排序的，所以，放入容器的对象所属的类，往往还应该重载==和<运算符。



									不同容器的迭代器
		容器								*		对应的迭代器类型
		*****************************************************************
		array								*		随机访问迭代器
		vector								*		随机访问迭代器
		deque								*		随机访问迭代器
		list								*		双向迭代器
		set / multiset						*		双向迭代器
		map / multimap						*		双向迭代器
		forward_list						*		前向迭代器
		unordered_map/unordered_multimap	*		前向迭代器					
		unordered_set/unordered_multiset	*		前向迭代器					
		stack								*		不支持迭代器
		queue								*		不支持迭代器
		priority_queue						*		不支持迭代器
		*****************************************************************
从表格中可看出 底层是数组实现的就是随机访问迭代器，底层不是数组的是双向迭代器，最后队列和栈因为不提供逐个访问的功能就不能用迭代器了


			顺序容器和关联容器都有的成员函数
*	begin：返回指向容器中第一个元素的迭代器
	end：返回指向容器中最后一个元素后面位置的迭代器
　　rbegin：返回容器中最后一个元素的迭代器
　　rend：返回指向容器中第一个元素前面位置的迭代器（r==reverse）
　　erase：从容器中删除一个或几个元素
　　clear：从容器中删除所有元素
*
* 			顺序容器的常用成员函数
*	front：返回容器中第一个元素的引用
　　back：返回容器中最后一个元素的引用
　　push_back：在容器末尾增加新元素
　　pop_back：删除容器末尾的元素
　　erase：删除迭代器指向的元素（可能会使得该迭代器失效），或删除一个区间，返回被删除元素后面那个元素的迭代器
*
*  			迭代器
*	1、用于指向顺序容器和关联容器中的元素
　　2、迭代器用法和指针类似
　　3、有const和非const两种
	4、通过迭代器可以读取它指向的元素
　　5、通过非const迭代器还能修改其指向的元素
　　定义一个容器类的迭代器的方法可以是：		容器类名::iterator 变量名;	或：容器类名::const_iterator 变量名;
　　访问一个迭代器指向的元素：		*迭代器变量名
　　迭代器上可以执行++操作，以使其指向容器中的下一个元素。如果迭代器到达了容器中的最后一个元素的后面，
	这时再使用它，就会出错，类似于使用NULL或未初始化的指针一样。

	  			算法简介
*	1、算法就是一个个函数模板，大多数在<algorithm>中定义
　　2、STL中提供能在各种容器中通用的算法，比如查找，排序等
　　3、算法通过迭代器来操纵容器中的元素。许多算法可以对容器中的一个局部区间进行操作，因此需要两个参数，一个是起始元素的迭代器，一个是终止元素的后面一个元素的迭代器。比如，排序和查找
　　4、有的算法返回一个迭代器。比如find()算法，在容器中查找一个元素，并返回一个指向该元素的迭代器
　　5、算法可以处理容器，也可以处理普通数组

  https://www.runoob.com/cplusplus/cpp-libs-algorithm.html
* ****************************************************************/


#include<iostream>
#include<vector>
using namespace std;

int main() {
	vector<int> v;						//一个存放int元素的数组，一开始里面没有元素
	v.push_back(1);
	v.push_back(2);
	v.push_back(3);
	v.push_back(4);
	vector<int>::const_iterator i;		//常量迭代器
	for (i = v.begin();i != v.end()-1;++i)
		cout << *i << ",";
	cout << *i << endl;


/*****************************************************************
*			反向迭代器
* ****************************************************************/
	vector<int>::reverse_iterator r;
	for (r = v.rbegin();r != v.rend()-1;++r)
		cout << *r << ",";
	cout << *r << endl;



/*****************************************************************
*			双向迭代器
*	若p和p1都是双向迭代器，则可对p、p1可进行以下操作:
	++p, p++			使p指向容器中下一个元素
	--p, p--			使p指向容器中上一个元素
	*p					取p指向的元素
	p = p1				赋值
	p == p1, p != p1	判断是否相等、不等

	注：双向迭代器的其他操作是不合法的，如，双向迭代器不支持 < 和 p[] 等等。
* ****************************************************************/

/*****************************************************************
*			随机访问迭代器
*	若p和p1都是随机访问迭代器，则可对p，p1进行以下操作：
	p += i				将p向后移动i个元素
	p -= i				将p向前移动i个元素
	p + i				值为 指向p后面的第i个元素的迭代器
	p - i				值为 指向p前面的第i个元素的迭代器
	p[i]				值为 p后面的第i个元素的引用
	p < p1，p <= p1，p > p1，p >= p1  都是合法的

* ****************************************************************/
	

	return 0;
}



